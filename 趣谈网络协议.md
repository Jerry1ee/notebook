# 趣谈网络协议

## 1.为什么要学习网络协议

### 协议三要素

- **语法**，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。
- **语义**，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。
- **顺序**，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。

### 常用的网络协议

#### 一个下单过程

#### 应用层

**URL**

先在浏览器里面输入 https://www.kaola.com ，浏览器只知道名字是“www.kaola.com”，但是不知道具体的地点，所以不知道应该如何访问

**DNS**

打开地址簿去找，也可以使用另一种更加精准的地址簿查找协议**HTTPDNS**。通过域名来对应最终的IP地址

**IP地址**

知道了目标地址，浏览器就开始打包请求

- 普通请求，使用HTTP协议
- 购物请求，加密传输使用HTTPS协议
- ![image-20200216162446363](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216162446363.png)
- DNS、HTTP、HTTPS所在的层我们称为**应用层**
- 应用层封装后，浏览器会将应用层的包交给下一层去完成，通过socket编程来实现

#### 传输层

- 下一层是**传输层**。传输层有两种协议，一种是无连接的协议**UDP**，一种是面向连接的协议**TCP**。对于支付来讲，往往使用TCP协议。所谓的面向连接就是，TCP会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。

![image-20200216162736484](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216162736484.png)

- 通过端口判断得到的包给哪个进程

#### 网络层

传输层封装完毕后，浏览器会将包交给操作系统的**网络层**

在IP协议里面会有源IP地址，即浏览器所在机器的IP地址和目标IP地址，也即电商网站所在服务器的IP地址。

![image-20200216162847370](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216162847370.png)

- 操作系统知道了目标IP
  - IP是本地的，从IP地址就可以看出
  - IP是外地的，就需要去找**网关**
- 操作系统启动时，就会被DHCP协议配置IP地址，及默认网关IP地址192.168.1.1
- 操作系统通过**ARP协议**将IP地址传给网关，传送到的地址为MAC地址
- ![image-20200216163325539](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216163325539.png)

#### MAC层

网卡将包发出去，包里有mac地址，可以到达网关

网关收到包后，根据**路由协议**（常用的有**OSPF**和**BGP**），路由到要去的最终MAC地址

#### 最终

最终MAC地址对上了，取下MAC头，发送给操作系统网络层。IP对上，取下IP头。IP头中写了上一层封装的是TCP协议，然后将其交给传输层，即TCP层

TCP头中有目标端口号，找到电商网站的进程，解析HTTP请求内容，知道了需求，告诉相关进程

通过RPC调用来告诉相关进程，当所有对应的部门进程都处理完毕，就回复一个HTTPS包，再通过来的过程，回到个人电脑上

![image-20200216164345842](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216164345842.png)

## 2.网络分层的真实含义

### 为什么要分层？

复杂的程序和处理过程都要分层，方便让每一层更加专注于做本层的事情

### 层与层之间的关系

TCP三次握手时，IP和MAC层也在做自己该做的工作，为TCP报文信息加头/解析头

**只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层**

## 3.ifconfig：最熟悉又陌生的命令行

**IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码**

分成五类

![image-20200216170406255](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216170406255.png)

A、B、C三类地址能包含的主机数量

![image-20200216170443183](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216170443183.png)

### 无类型域间选路（CIDR）

- 将 32 位的 IP 地址一分为二，前面是**网络号**，后面是**主机号**

#### 10.100.122.2/24

- 这个 IP 地址中有一个斜杠，斜杠后面有个数字 24，后面 24 的意思是，**32 位中，前 24 位是网络号，后 8 位是主机号**

#### **广播地址**

10.100.122.255。发送这个地址，所有10.100.122 网络里面的机器都可以收到

#### **子网掩码**

255.255.255.0。将子网掩码和IP地址按位计算AND，就能得到网络号，因为后8位全是0，取AND时仍为0，前24为全为1，取AND仍为原值

### 公有 IP 地址和私有 IP 地址

公有地址与外界交流

私有地址用于内部交流

### 举例：一个容易“犯错”的 CIDR

**16.158.165.91/22**

/22 不是 8 的整数倍，不好办，只能先变成二进制来看。16.158 的部分不会动，它占了前 16 位。中间的 165，变为二进制为‭10100101‬。除了前面的 16 位，还剩 6 位。所以，这 8 位中前 6 位是网络号，16.158.<101001>，而 <01>.91 是机器号

第一个地址是 16.158.<101001><00>.1，即 16.158.164.1。子网掩码是 255.255.<111111><00>.0，即 255.255.252.0。广播地址为 16.158.<101001><11>.255，即 16.158.167.255

### **组播地址**

使用这一类地址，属于某个组的机器都能收到

### ip addr分析

#### IP地址后的scope

eth0是global，可以对外，可以接收各个地方的包；lo是host，仅仅供本机通信

lo 全称是**loopback**，又称**环回接口**，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现

#### MAC地址

IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff

是一个网卡的物理地址，用十六进制，6 个 byte 表示

#### **为什么不能直接用全局唯一的MAC地址通信？**

**一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。** 而有门牌号码属性的 IP 地址，才是有远程定位功能的

但MAC地址也有一定定位功能，但范围很小

所以MAC地址通讯范围较小，局限在一个子网里面

#### 网络设备的状态标识（**net_device flags）**

**<BROADCAST,MULTICAST,UP,LOWER_UP>**

- UP 表示网卡处于启动的状态；
- BROADCAST 表示这个网卡有广播地址，可以发送广播包；
- MULTICAST 表示网卡可以发送多播包；
- LOWER_UP 表示 L1 是启动的，也即网线插着呢

#### MTU1500 

最大传输单元 MTU 为 1500，这是以太网的默认值，MTU是二层MAC层的概念。

MAC层有MAC的头，正文（IP头、TCP头、HTTP头等）加MAC头，不允许超过1500字节，超过就要分片传输

#### qdisc pfifo_fast

qdisc全称**queueing discipline**，中文叫 排队规则，pfifo 先进先出

pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则

每个波段有优先级，先处理优先级高的波段

数据包是按照服务类型（**Type of Service，TOS**）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的

## 4.DHCP与PXE：IP是怎么来的，又是怎么没的？

### 如何配置IP地址？

**使用 net-tools：**

```
$ sudo ifconfig eth1 10.0.0.1/24
$ sudo ifconfig eth1 up
```

**使用 iproute2：**

```
$ sudo ip addr add 10.0.0.1/24 dev eth1
$ sudo ip link set up eth1
```

**为什么同一个交换机上，我地址是16.158.23.6，去ping另一台192.168.1.6，却ping不通？**

- 包不完整，MAC层填不了

- Linux默认逻辑，如果是一个跨网段的调用，不会直接将包发送到网络上，而是企图将包发送到网关
- 虽然目标IP是对的，但是MAC地址匹配不上，就无法将包收入

### 动态主机配置协议（DHCP）

只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了

等人走了，或者用完了，还回去，这样其他的机器也能用

#### 解析 DHCP 的工作方式

**DHCP Discover**

新来的机器使用IP地址0.0.0.0发送一个广播包，目的IP地址为255.255.255.255，广播包封装了UDP，UDP封装了BOOTP

![image-20200216173519916](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216173519916.png)

**DHCP Offer**（来自DHCP Server）

只有 MAC 唯一，IP 管理员才能知道这是一个新人，需要租给它一个 IP 地址，这个过程我们称为**DHCP Offer**，同时，**DHCP Server** 为此客户保留为它提供的 IP 地址，从而不会为其他 DHCP 客户分配此 IP 地址

格式如下

![image-20200216173631497](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216173631497.png)

DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。此外，服务器还发送了子网掩码、网关和IP地址租用期等信息

 **DHCP Request** 

![image-20200216173918240](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216173918240.png)

回复自己的选择，此时DHCP Server还没有确认，它仍然使用0.0.0.0作为源IP地址、255.255.255.255为目标广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP

**DHCP ACK**

 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭

![image-20200216174131587](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200216174131587.png)

### IP 地址的收回和续租

- 客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包
- 客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置
- 这样，IP 租用更新就完成了

### 预启动执行环境（PXE）

​	PXE 协议分为客户端和服务器端，由于还没有操作系统，只能先把客户端放在 BIOS 里面。当计算机启动时，BIOS 把 PXE 客户端调入内存里面，就可以连接到服务端做一些操作了。

- PXE客户端自己需要有个IP地址
- 发送DHCP请求，得到一个IP地址，并得知PXE服务器位置，下载文件并初始化系统

### PXE工作过程

![image-20200217113618949](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217113618949.png)



## 10.UDP协议

### TCP和UDP的区别

TCP面向连接，UDP面向无连接？

**所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性**

- **TCP提供可靠交付**。通过TCP连接传输的数据，无差错、不丢失、不重复、按序到达。
- **UDP不保证不丢失，不保证按顺序到达。**
- **TCP面向字节流。**没头没尾，不像IP一样是一个一个的包
- **UDP继承IP特性，基于数据报，一个一个地发，一个一个地收**
- **TCP具有拥塞控制**。包丢了或者网络环境不好了，会调整行为，发送慢点或快点
- **UDP只管发送，不管网络状态或结果如何**
- **TCP是有状态服务**，精确记录发送了没有，收到没有，发送的进度和应该接收哪些
- **UDP是无状态服务**，发出去后不管其他的

### UDP的包头

![image-20200217115334020](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217115334020.png)

### UDP**三大特点**

- **沟通简单，**默认网络通路容易送达，不容易被丢弃
- **轻信他人，**不会建立连接，监听的端口号可以接收任何人的数据，也可以传给任何人
- **不懂变通，**不知道什么时候该坚持，什么时候该退让。不会根据网络情况进行拥塞控制

### UDP**的三大使用场景**

- 资源少，网络情况好的内网，或丢包不敏感的应用（DHCP，TFTP）
- 不需要一对一沟通，建立连接，可以**广播**的应用（IGMP，组播，VXLAN）
- 需要处理速度快，**时延低，容忍少数丢包**，但要求即使网络拥塞，也不能退避
- 在应用层实现自己的连接策略，又有时延需求

### **基于UDP的应用层示例**

#### 网页/APP的访问

**QUIC**（全称**Quick UDP Internet Connections**，**快速UDP互联网连接**）

Google提出的，基于UDP改进的通信协议，**目的是降低网络通信延迟，提供更好的用户互动体验**

#### 流媒体协议

视频播放，有的包可丢，有的包不能丢。可以选择性丢帧，但不能连续丢帧

很多直播应用都基于UDP实现了自己的视频传输协议

#### 实时游戏

游戏对实时要求较为严格的情况下，采用自定义的可靠UDP协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响

#### IoT物联网

- 物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护TCP协议代价太大
- 另一方面，物联网对实时性要求也很高，而TCP还是因为上面的那些原因导致时延大。
- Google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，就是基于UDP协议的

#### 移动通信领域

4G网络里，移动流量上网的数据面对的协议GTP-U是基于UDP的

## 11.TCP协议（上）

它天然认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。

### TCP包头格式

![image-20200217114104659](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217114104659.png)

- 源端口号，目标端口号必不可少
- 包的序号
  - 解决乱序问题，确认哪个先来，哪个后到
- 确认序号
  - 发出去的包要有确认，这样才能知道对方有没有收到
  - 没收到就重新发送，直到送达，解决不丢包的问题
- IP层面没有任何可靠性保证，TCP唯一能做的，就是**不断重传，用各种算法保证**
- 状态位
  - SYN是发起一个连接
  - ACK是回复
  - RST是重新连接
  - FIN是结束连接...
  - TCP是面向连接的，双方要维护连接的状态，这些带状态位的包发送，会引起双方状态变更
- 窗口大小
  - 流量控制，双方各声明一个窗口，标识自己能处理的多少内容，别发太多，月别发太少
- 拥塞控制
- **总结**
  - 有顺序（包序号），不丢包（确认序号），维护连接（不断重传，状态位，算法保证），流量控制（窗口大小），拥塞控制（限制自己发送的快慢）

### 三次握手

A：您好，我是A。

B：您好A，我是B。

A：您好B。

请求->应答->应答之应答

#### 为什么不是两次？为什么不是四次？

A发送请求连接，有可能收不到回复，有可能饶了很多弯路，很久才到达B那里；

B收到了，如果不愿意建立连接，A重试一阵就放弃，如果愿意，他会发送回应给A；

**这时候已经两次握手了，但B也不知道自己的回应能不能到达A，于是他也要求收到回复**

只有等到自己发出去的消息收到回复，才算是可靠的连接

最后A应答B的回应，发送到B，成功建立连接

**当然四次连接也可以，但是只要双方消息都有去有回，就可以了**

#### **TCP包的序号的问题**

A要告诉B，我发送的包序号从哪个开始；B也要告诉A，B发起的包序号从哪个开始，防止网络状况不好造成包的冲突

起始序号随着时间变化，可看作一个32位的计数器，每4ms加一

#### 状态变化时序图

双方为了维护这个连接，都要维护一个状态机，建立过程中，双方的状态变化时序图如下

![image-20200217122922775](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217122922775.png)

- 开始都处于CLOSED状态
- 服务端主动监听某个端口，处于LISTEN状态
- 客户端主动发起连接SYN，之后处于SYN-SENT状态
- 服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD
- 客户端收到服务端发来的SYN和ACK，发送ACK的ACK，之后一直处于ESTABLISHED
- 服务端收到ACK的ACK后，处于ESTABLISHED，因为都一发一收了

### TCP四次挥手

A：B，我不想玩了。

B：哦，你不想玩了啊，我知道了。

这个时候，还只是A不想玩了，也即A不会再发送数据，但是B不能在ACK的时候，直接关闭，因为很有可能A是发完了最后的数据就准备不玩了，但是B还没做完自己的事情，还是可以发送数据的，所以称为半关闭的状态。

这个时候A可以选择不再接收数据了，也可以选择最后再接收一段数据，等待B也主动关闭。

B：A啊，好吧，我也不玩了，拜拜。

A：好的，拜拜。

#### 异常情况

A发完不玩了，直接跑路，B发起结束得不到回答；A发完不玩了，B直接跑路，A不知道B是有事，还是要过一会才发送结束

#### TCP断开连接时的状态时序图

![image-20200217124110767](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217124110767.png)

- A说不玩了，就进入FIN-WAIT-1状态
- B收到后，发送知道了ACK，进入CLOSE-WAIT状态
- A收到B说知道了，进入FIN-WAIT-2状态，若B直接跑了，A将永远处在这个状态（TCP协议中没有对这个状态的处理，Linux中可以调整tcp_fin_timeout设置一个超时时间）
- B也发送 不玩了，请求到达A后，A发送知道 B不玩了的ACK，从FIN-WAIT-2结束，这时候为了确保B能收到这个ACK，要求A要等待一段时间TIME-WAIT，这个时间要足够长，长到如果B没收到ACK，B重发，A再次重发ACK并足够时间到达B
- A如果直接跑了就还有一个问题，A的端口空出来了，但B不知道，B原来发过的很多包很可能还在路上，所以要等待足够长的时间，让B还没发过来的包都死掉
- 等待时间设置为2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间。是任何报文在网络上存在的最长时间，超过这个时间报文就会被丢弃。TCP报文基于IP协议，IP头中有一个TTL域，是IP数据报可以经过的最大路由数，每经过一个处理它的路由器就减一，到0就被丢弃。同时发送ICMP报文通知源主机。规定MSL为2分钟，实际应用中常用的是30秒，1分钟，2分钟等
- 如果超过了2MSL，B还会重发FIN，但A接收到这个包时，表明已经等待过久，直接发送RST，B就知道A已经不在了

### TCP状态机

![image-20200217150424417](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217150424417.png)

## 12.TCP协议（下）

### 如何实现一个靠谱的协议

- 为了保证顺序性，每个包都有一个ID。在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送

- 为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的ID，表示都收到了，这种模式称为**累计确认**或者**累计应答**（**cumulative acknowledgment**）

为了记录所有发送和接收的包，TCP需要发送接收端都有缓存来保存这些记录

#### 发送端缓存（按ID一个个排列）

- 发送了并已经确认的
- 发送了并尚未确认的
- 没有发送但等待发送
- 没有发送且暂时不会发送

#### **Advertised window**

接收端给发送端报的窗口大小，等于第二部分加第三部分（没做完的和马上要交代的）

![image-20200217151405400](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217151405400.png)

- LastByteAcked：第一部分和第二部分的分界线
- LastByteSent：第二部分和第三部分的分界线
- LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

#### 接收端缓存

- 接收并确认过的
- 还没接收，马上能接收的（最大工作量）
- 还没接收也没法接收的

![image-20200217153636942](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217153636942.png)

- MaxRcvBuffer：最大缓存的量；
- LastByteRead之后是已经接收了，但是还没被应用层读取的；
- NextByteExpected是第一部分和第二部分的分界线。

AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)

### 顺序问题与丢包问题

具体场景：

- 发送端来看，1、2、3已经发送并确认；4、5、6、7、8、9都是发送了还没确认；10、11、12是还没发出的；13、14、15是接收方没有空间，不准备发的。
- 接收端来看，1、2、3、4、5是已经完成ACK，但是没读取的；6、7是等待接收的；8、9是已经接收，但是没有ACK的。
- 发送端和接收端当前的状态如下：
  - 1、2、3没有问题，双方达成了一致。
  - 4、5接收方说ACK了，但是发送方还没收到，有可能丢了，有可能在路上。
  - 6、7、8、9肯定都发了，但是8、9已经到了，但是6、7没到，出现了乱序，缓存着但是没办法ACK。

#### **确认与重发的机制**

对每个发送了，但是没有ACK的包，都设一个定时器，超过一定时间就重新尝试（必须大于往返时间RTT，也不能过长）

**自适应算法**

TCP通过采样RTT的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样RTT，还要采样RTT的波动范围，计算出一个估计的超时时间

**超时间隔加倍**

**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**。**两次超时，就说明网络环境差，不宜频繁反复发送**

**快速重传**

当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段

接收方发现6、8、9都已经接收了，就是7没来，那肯定是丢了，于是发送三个6的ACK，要求下一个是7。客户端收到3个，就会发现7的确又丢了，不等超时，马上重发

**Selective Acknowledgment** 

这种方式需要在TCP头里加一个SACK的东西，可以将缓存的地图发送给发送方。例如可以发送ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是7丢了。

### 流量控制问题

接收方处理比较慢时，导致缓存中没有空间了，可以适当减小发送端的窗口大小，甚至为0

可以当窗口太小的时候，不更新窗口，直到达到一定大小，或者缓冲区一半为空，才更新窗口

### 拥塞控制问题

前面的滑动窗口rwnd是怕发送方把接收方缓存塞满，而拥塞窗口cwnd，是怕把网络塞满

####  拥塞窗口和滑动窗口共同控制发送的速度

LastByteSent - LastByteAcked <= min {cwnd, rwnd} 

![image-20200217165957399](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217165957399.png)

上面是一个往返时间为8s，1234已经接收确认，5678已经发送还没有接收的情况

#### **拥塞控制解决 包丢失**和**超时重传**

- 丢包并不代表通道满了，可能本身公网就会丢包，这时认为拥塞了就限制发送是不对的

- TCP拥塞机制等到中间设备都填充满了，才发生丢包，从而降低速度，此时已经晚了

- 优化解决：

  - **TCP BBR拥塞算法**
  - 通过不断加快发送速度，将管道填满，但又不填满中间设备的缓存
  - 达到一个平衡点

  ![image-20200217172336230](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200217172336230.png)

  